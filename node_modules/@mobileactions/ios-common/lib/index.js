"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var path = require("path");
var core = require("@actions/core");
var io = require("@actions/io");
var exec = require('@actions/exec');
var ioutils = require("@mobileactions/actions-common");
/**
 * Creates a temporary keychain and installs the P12 cert in the temporary keychain
 * @param keychainPath the path to the keychain file
 * @param keychainPwd the password to use for unlocking the keychain
 * @param p12CertPath the P12 cert to be installed in the keychain
 * @param p12Pwd the password for the P12 cert
 * @param useKeychainIfExists Pass false to delete and recreate a preexisting keychain
 */
function installCertInTemporaryKeychain(keychainPath, keychainPwd, p12CertPath, p12Pwd, useKeychainIfExists) {
    return __awaiter(this, void 0, void 0, function () {
        var setupKeychain, securityCmd, privateKeyName, listAllOutput, listAllOpts, allKeychainsArr, listAddArgs, i, listVerifyOutput, listVerifyOpts;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    setupKeychain = true;
                    if (useKeychainIfExists && ioutils.exists(keychainPath)) {
                        setupKeychain = false;
                    }
                    return [4 /*yield*/, io.which('security', true)];
                case 1:
                    securityCmd = _a.sent();
                    if (!setupKeychain) return [3 /*break*/, 5];
                    //delete keychain if exists
                    return [4 /*yield*/, deleteKeychain(keychainPath)];
                case 2:
                    //delete keychain if exists
                    _a.sent();
                    //create keychain
                    return [4 /*yield*/, exec.exec(securityCmd, ['create-keychain', '-p', keychainPwd, keychainPath])];
                case 3:
                    //create keychain
                    _a.sent();
                    //update keychain settings, keep keychain unlocked for 6h = 21600 sec, which is the job timeout for paid hosted VMs
                    return [4 /*yield*/, exec.exec(securityCmd, ['set-keychain-settings', '-lut', '21600', keychainPath])];
                case 4:
                    //update keychain settings, keep keychain unlocked for 6h = 21600 sec, which is the job timeout for paid hosted VMs
                    _a.sent();
                    _a.label = 5;
                case 5: 
                //unlock keychain
                return [4 /*yield*/, unlockKeychain(keychainPath, keychainPwd)];
                case 6:
                    //unlock keychain
                    _a.sent();
                    //import p12 cert into the keychain
                    if (!p12Pwd) {
                        // if password is null or not defined, set it to empty
                        p12Pwd = '';
                    }
                    return [4 /*yield*/, exec.exec(securityCmd, ['import', p12CertPath, '-P', p12Pwd, '-A', '-t', 'cert', '-f', 'pkcs12', '-k', keychainPath])];
                case 7:
                    _a.sent();
                    if (!!setupKeychain) return [3 /*break*/, 10];
                    return [4 /*yield*/, getP12PrivateKeyName(p12CertPath, p12Pwd)];
                case 8:
                    privateKeyName = _a.sent();
                    return [4 /*yield*/, setKeyPartitionList(keychainPath, keychainPwd, privateKeyName)];
                case 9:
                    _a.sent();
                    _a.label = 10;
                case 10:
                    listAllOpts = {};
                    listAllOpts.listeners = {
                        stdout: function (data) {
                            if (data) {
                                if (listAllOutput) {
                                    listAllOutput = listAllOutput.concat(data.toString().trim());
                                }
                                else {
                                    listAllOutput = data.toString().trim();
                                }
                            }
                        }
                    };
                    return [4 /*yield*/, exec.exec(securityCmd, ['list-keychain', '-d', 'user'], listAllOpts)];
                case 11:
                    _a.sent();
                    allKeychainsArr = [];
                    core.debug('listAllOutput = ' + listAllOutput);
                    //parse out all the existing keychains in search path
                    if (listAllOutput) {
                        allKeychainsArr = listAllOutput.split(/[\n\r\f\v]/gm);
                    }
                    if (!(listAllOutput && listAllOutput.indexOf(keychainPath) < 0)) return [3 /*break*/, 13];
                    listAddArgs = ['list-keychain', '-d', 'user', '-s', keychainPath];
                    for (i = 0; i < allKeychainsArr.length; i++) {
                        listAddArgs.push(allKeychainsArr[i].trim().replace(/"/gm, ''));
                    }
                    return [4 /*yield*/, exec.exec(securityCmd, listAddArgs)];
                case 12:
                    _a.sent();
                    _a.label = 13;
                case 13:
                    listVerifyOpts = {};
                    listVerifyOpts.listeners = {
                        stdout: function (data) {
                            if (data) {
                                if (listVerifyOutput) {
                                    listVerifyOutput = listVerifyOutput.concat(data.toString().trim());
                                }
                                else {
                                    listVerifyOutput = data.toString().trim();
                                }
                            }
                        }
                    };
                    return [4 /*yield*/, exec.exec(securityCmd, ['list-keychain', '-d', 'user'], listVerifyOpts)];
                case 14:
                    _a.sent();
                    if (!listVerifyOutput || listVerifyOutput.indexOf(keychainPath) < 0) {
                        throw ('TempKeychainSetupFailed');
                    }
                    return [2 /*return*/];
            }
        });
    });
}
exports.installCertInTemporaryKeychain = installCertInTemporaryKeychain;
/**
 * Finds an iOS codesigning identity in the specified keychain
 * @param keychainPath
 * @returns {string} signing identity found
 */
function findSigningIdentity(keychainPath) {
    return __awaiter(this, void 0, void 0, function () {
        var signIdentity, securityCmd, findIdentityOpts;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, io.which('security', true)];
                case 1:
                    securityCmd = _a.sent();
                    findIdentityOpts = {};
                    findIdentityOpts.listeners = {
                        stdout: function (data) {
                            if (data) {
                                var matches = data.toString().trim().match(/"(.+)"/g);
                                core.debug('signing identity data = ' + matches);
                                if (matches && matches[0]) {
                                    signIdentity = matches[0].replace(/"/gm, '');
                                    core.debug('signing identity data trimmed = ' + signIdentity);
                                }
                            }
                        }
                    };
                    return [4 /*yield*/, exec.exec(securityCmd, ['find-identity', '-v', '-p', 'codesigning', keychainPath], findIdentityOpts)];
                case 2:
                    _a.sent();
                    if (signIdentity) {
                        core.debug('findSigningIdentity = ' + signIdentity);
                        return [2 /*return*/, signIdentity];
                    }
                    else {
                        throw ('SignIdNotFound');
                    }
                    return [2 /*return*/];
            }
        });
    });
}
exports.findSigningIdentity = findSigningIdentity;
/**
 * Get Cloud entitlement type Production or Development according to the export method - if entitlement doesn't exists in provisioning profile returns null
 * @param provisioningProfilePath
 * @param exportMethod
 * @returns {string}
 */
function getCloudEntitlement(provisioningProfilePath, exportMethod) {
    return __awaiter(this, void 0, void 0, function () {
        var tmpPlist, cloudEntitlement;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    tmpPlist = '_xcodetasktmp.plist';
                    return [4 /*yield*/, saveProvisioningProfileDetails(provisioningProfilePath, tmpPlist)];
                case 1:
                    _a.sent();
                    return [4 /*yield*/, execPlistBuddyCommand('Print Entitlements:com.apple.developer.icloud-container-environment', tmpPlist)];
                case 2:
                    cloudEntitlement = _a.sent();
                    //delete the temporary plist file
                    return [4 /*yield*/, io.rmRF(tmpPlist)];
                case 3:
                    //delete the temporary plist file
                    _a.sent();
                    if (!cloudEntitlement) {
                        return [2 /*return*/, null];
                    }
                    core.debug('Provisioning Profile contains cloud entitlement');
                    return [2 /*return*/, (exportMethod === 'app-store' || exportMethod === 'enterprise' || exportMethod === 'developer-id')
                            ? "Production"
                            : "Development"];
            }
        });
    });
}
exports.getCloudEntitlement = getCloudEntitlement;
/**
 * Find the UUID and Name of the provisioning profile and install the profile
 * @param provProfilePath
 * @returns { provProfileUUID, provProfileName }
 */
function installProvisioningProfile(provProfilePath) {
    return __awaiter(this, void 0, void 0, function () {
        var tmpPlist, provProfileUUID, provProfileName, pathToProvProfile, cpCmd, cpArgs;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    tmpPlist = '_xcodetasktmp.plist';
                    return [4 /*yield*/, saveProvisioningProfileDetails(provProfilePath, tmpPlist)];
                case 1:
                    _a.sent();
                    return [4 /*yield*/, execPlistBuddyCommand('Print UUID', tmpPlist)];
                case 2:
                    provProfileUUID = _a.sent();
                    return [4 /*yield*/, execPlistBuddyCommand('Print Name', tmpPlist)];
                case 3:
                    provProfileName = _a.sent();
                    //delete the temporary plist file
                    return [4 /*yield*/, io.rmRF(tmpPlist)];
                case 4:
                    //delete the temporary plist file
                    _a.sent();
                    if (!provProfileUUID) return [3 /*break*/, 7];
                    //copy the provisioning profile file to ~/Library/MobileDevice/Provisioning Profiles
                    io.mkdirP(getUserProvisioningProfilesPath()); // Path may not exist if Xcode has not been run yet.
                    core.debug('created directory: ' + getUserProvisioningProfilesPath());
                    pathToProvProfile = getProvisioningProfilePath(provProfileUUID, provProfilePath);
                    core.debug('copying provisioning profile to destination: ' + pathToProvProfile);
                    return [4 /*yield*/, io.which('cp', true)];
                case 5:
                    cpCmd = _a.sent();
                    cpArgs = ['-f', provProfilePath, pathToProvProfile];
                    return [4 /*yield*/, exec.exec(cpCmd, cpArgs)];
                case 6:
                    _a.sent();
                    if (!provProfileName) {
                        core.warning('ProvProfileNameNotFound');
                        provProfileName = '';
                    }
                    return [2 /*return*/, { provProfileUUID: provProfileUUID, provProfileName: provProfileName }];
                case 7: throw new Error('ProvProfileUUIDNotFound: ' + provProfilePath);
            }
        });
    });
}
exports.installProvisioningProfile = installProvisioningProfile;
/**
 * Find the Name of the provisioning profile
 * @param provProfilePath
 * @returns {string} Name
 */
function getProvisioningProfileName(provProfilePath) {
    return __awaiter(this, void 0, void 0, function () {
        var tmpPlist, provProfileDetails, provProfileName;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    tmpPlist = '_xcodetasktmp.plist';
                    return [4 /*yield*/, saveProvisioningProfileDetails(provProfilePath, tmpPlist)];
                case 1:
                    provProfileDetails = _a.sent();
                    return [4 /*yield*/, execPlistBuddyCommand('Print Name', tmpPlist)];
                case 2:
                    provProfileName = _a.sent();
                    //delete the temporary plist file
                    return [4 /*yield*/, io.rmRF(tmpPlist)];
                case 3:
                    //delete the temporary plist file
                    _a.sent();
                    core.debug('getProvisioningProfileName: profile name = ' + provProfileName);
                    return [2 /*return*/, provProfileName];
            }
        });
    });
}
exports.getProvisioningProfileName = getProvisioningProfileName;
/**
 * Find the type of the iOS provisioning profile - app-store, ad-hoc, enterprise or development
 * @param provProfilePath
 * @returns {string} type
 */
function getiOSProvisioningProfileType(provProfilePath) {
    return __awaiter(this, void 0, void 0, function () {
        var provProfileType, tmpPlist, provisionsAllDevices, getTaskAllow, provisionedDevices, err_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 9, , 10]);
                    tmpPlist = '_xcodetasktmp.plist';
                    return [4 /*yield*/, saveProvisioningProfileDetails(provProfilePath, tmpPlist)];
                case 1:
                    _a.sent();
                    return [4 /*yield*/, execPlistBuddyCommand('Print ProvisionsAllDevices', tmpPlist)];
                case 2:
                    provisionsAllDevices = _a.sent();
                    core.debug('provisionsAllDevices = ' + provisionsAllDevices);
                    if (!(provisionsAllDevices && provisionsAllDevices.trim().toLowerCase() === 'true')) return [3 /*break*/, 3];
                    //ProvisionsAllDevices = true in enterprise profiles
                    provProfileType = 'enterprise';
                    return [3 /*break*/, 7];
                case 3: return [4 /*yield*/, execPlistBuddyCommand('Print Entitlements:get-task-allow', tmpPlist)];
                case 4:
                    getTaskAllow = _a.sent();
                    core.debug('getTaskAllow = ' + getTaskAllow);
                    if (!(getTaskAllow && getTaskAllow.trim().toLowerCase() === 'true')) return [3 /*break*/, 5];
                    //get-task-allow = true means it is a development profile
                    provProfileType = 'development';
                    return [3 /*break*/, 7];
                case 5: return [4 /*yield*/, execPlistBuddyCommand('Print ProvisionedDevices', tmpPlist)];
                case 6:
                    provisionedDevices = _a.sent();
                    core.debug('provisionedDevices = ' + provisionedDevices);
                    if (!provisionedDevices) {
                        // no provisioned devices for non-development profile means it is an app-store profile
                        provProfileType = 'app-store';
                    }
                    else {
                        // non-development profile with provisioned devices - use ad-hoc
                        provProfileType = 'ad-hoc';
                    }
                    _a.label = 7;
                case 7: 
                //delete the temporary plist file
                return [4 /*yield*/, io.rmRF(tmpPlist)];
                case 8:
                    //delete the temporary plist file
                    _a.sent();
                    return [3 /*break*/, 10];
                case 9:
                    err_1 = _a.sent();
                    core.debug(err_1);
                    return [3 /*break*/, 10];
                case 10: return [2 /*return*/, provProfileType];
            }
        });
    });
}
exports.getiOSProvisioningProfileType = getiOSProvisioningProfileType;
/**
 * Find the type of the macOS provisioning profile - app-store, developer-id or development.
 * mac-application is a fourth macOS export method, but it doesn't include signing.
 * @param provProfilePath
 * @returns {string} type
 */
function getmacOSProvisioningProfileType(provProfilePath) {
    return __awaiter(this, void 0, void 0, function () {
        var provProfileType, tmpPlist, provisionsAllDevices, provisionedDevices, err_2;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 7, , 8]);
                    tmpPlist = '_xcodetasktmp.plist';
                    return [4 /*yield*/, saveProvisioningProfileDetails(provProfilePath, tmpPlist)];
                case 1:
                    _a.sent();
                    return [4 /*yield*/, execPlistBuddyCommand('Print ProvisionsAllDevices', tmpPlist)];
                case 2:
                    provisionsAllDevices = _a.sent();
                    core.debug('provisionsAllDevices = ' + provisionsAllDevices);
                    if (!(provisionsAllDevices && provisionsAllDevices.trim().toLowerCase() === 'true')) return [3 /*break*/, 3];
                    //ProvisionsAllDevices = true in developer-id profiles
                    provProfileType = 'developer-id';
                    return [3 /*break*/, 5];
                case 3: return [4 /*yield*/, execPlistBuddyCommand('Print ProvisionedDevices', tmpPlist)];
                case 4:
                    provisionedDevices = _a.sent();
                    if (!provisionedDevices) {
                        // no provisioned devices means it is an app-store profile
                        provProfileType = 'app-store';
                    }
                    else {
                        // profile with provisioned devices - use development
                        provProfileType = 'development';
                    }
                    _a.label = 5;
                case 5: 
                //delete the temporary plist file
                return [4 /*yield*/, io.rmRF(tmpPlist)];
                case 6:
                    //delete the temporary plist file
                    _a.sent();
                    return [3 /*break*/, 8];
                case 7:
                    err_2 = _a.sent();
                    core.debug(err_2);
                    return [3 /*break*/, 8];
                case 8: return [2 /*return*/, provProfileType];
            }
        });
    });
}
exports.getmacOSProvisioningProfileType = getmacOSProvisioningProfileType;
/**
 * Unlock specified iOS keychain
 * @param keychainPath
 * @param keychainPwd
 */
function unlockKeychain(keychainPath, keychainPwd) {
    return __awaiter(this, void 0, void 0, function () {
        var unlockCommand;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, io.which('security', true)];
                case 1:
                    unlockCommand = _a.sent();
                    return [4 /*yield*/, exec.exec(unlockCommand, ['unlock-keychain', '-p', keychainPwd, keychainPath])];
                case 2:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    });
}
exports.unlockKeychain = unlockKeychain;
/**
 * Delete specified iOS keychain
 * @param keychainPath
 */
function deleteKeychain(keychainPath) {
    return __awaiter(this, void 0, void 0, function () {
        var deleteKeychainCommand;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!ioutils.exists(keychainPath)) return [3 /*break*/, 3];
                    return [4 /*yield*/, io.which('security', true)];
                case 1:
                    deleteKeychainCommand = _a.sent();
                    return [4 /*yield*/, exec.exec(deleteKeychainCommand, ['delete-keychain', keychainPath])];
                case 2:
                    _a.sent();
                    _a.label = 3;
                case 3: return [2 /*return*/];
            }
        });
    });
}
exports.deleteKeychain = deleteKeychain;
/**
 * Delete provisioning profile with specified UUID in the user's profiles directory
 * @param uuid
 */
function deleteProvisioningProfile(uuid) {
    return __awaiter(this, void 0, void 0, function () {
        var findCmd, provProfilesDir_1, findArgs, findOpts;
        var _this = this;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!(uuid && uuid.trim())) return [3 /*break*/, 3];
                    return [4 /*yield*/, io.which('ls', true)];
                case 1:
                    findCmd = _a.sent();
                    provProfilesDir_1 = getUserProvisioningProfilesPath();
                    findArgs = ['-1', provProfilesDir_1 + '/' + uuid.trim() + '*'];
                    findOpts = {};
                    findOpts.listeners = {
                        stdline: function (data) { return __awaiter(_this, void 0, void 0, function () {
                            var profPath;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        profPath = provProfilesDir_1 + '/' + data;
                                        if (!ioutils.exists(profPath)) return [3 /*break*/, 2];
                                        console.log('Deleting provisioning profile: ' + profPath);
                                        return [4 /*yield*/, io.rmRF(profPath)];
                                    case 1:
                                        _a.sent();
                                        _a.label = 2;
                                    case 2: return [2 /*return*/];
                                }
                            });
                        }); }
                    };
                    return [4 /*yield*/, exec.exec(findCmd, findArgs, findOpts)];
                case 2:
                    _a.sent();
                    _a.label = 3;
                case 3: return [2 /*return*/];
            }
        });
    });
}
exports.deleteProvisioningProfile = deleteProvisioningProfile;
/**
 * Gets the path to the iOS default keychain
 */
function getDefaultKeychainPath() {
    return __awaiter(this, void 0, void 0, function () {
        var defaultKeychainPath, getKeychainCmd, getKeyChainOpts;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    defaultKeychainPath = '';
                    return [4 /*yield*/, io.which('security', true)];
                case 1:
                    getKeychainCmd = _a.sent();
                    getKeyChainOpts = {};
                    getKeyChainOpts.listeners = {
                        stdout: function (data) {
                            if (data) {
                                defaultKeychainPath = data.toString().trim().replace(/[",\n\r\f\v]/gm, '');
                                if (!ioutils.exists(defaultKeychainPath)) {
                                    throw new Error('Received invalid default keychain path.');
                                }
                            }
                        }
                    };
                    return [4 /*yield*/, exec.exec(getKeychainCmd, ['default-keychain'], getKeyChainOpts)];
                case 2:
                    _a.sent();
                    return [2 /*return*/, defaultKeychainPath];
            }
        });
    });
}
exports.getDefaultKeychainPath = getDefaultKeychainPath;
/**
 * Gets the path to the temporary keychain path used during build or release
 */
function getTempKeychainPath() {
    var keychainName = 'ios_signing_temp.keychain';
    var getTempKeychainPath = path.resolve('/tmp', keychainName);
    return getTempKeychainPath;
}
exports.getTempKeychainPath = getTempKeychainPath;
/**
 * Get several x509 properties from the certificate in a P12 file.
 * @param p12Path Path to the P12 file
 * @param p12Pwd Password for the P12 file
 */
function getP12Properties(p12Path, p12Pwd) {
    return __awaiter(this, void 0, void 0, function () {
        function onLine(line) {
            if (line) {
                var tuple = splitIntoKeyValue(line);
                var key = (tuple) ? tuple.key : '';
                var value = (tuple) ? tuple.value : '';
                if (key === 'SHA1 Fingerprint') {
                    // Example value: "BB:26:83:C6:AA:88:35:DE:36:94:F2:CF:37:0A:D4:60:BB:AE:87:0C"
                    // Remove colons separating each octet.
                    fingerprint = value.replace(/:/g, '').trim();
                }
                else if (key === 'subject') {
                    // Example value: "/UID=E848ASUQZY/CN=iPhone Developer: Chris Sidi (7RZ3N927YF)/OU=DJ8T2973U7/O=Chris Sidi/C=US"
                    // Extract the common name.
                    var matches = value.match(/\/CN=([^/]+)/);
                    if (matches && matches[1]) {
                        commonName = matches[1].trim();
                    }
                }
                else if (key === 'notBefore') {
                    // Example value: "Nov 13 03:37:42 2018 GMT"
                    notBefore = new Date(value);
                }
                else if (key === 'notAfter') {
                    notAfter = new Date(value);
                }
            }
        }
        var output, fingerprint, commonName, notBefore, notAfter, opensslcmd, opensslopts, line, _i, _a, err_3;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    output = '';
                    if (!p12Pwd) {
                        // if password is null or not defined, set it to empty
                        p12Pwd = '';
                    }
                    return [4 /*yield*/, io.which('openssl', true)];
                case 1:
                    opensslcmd = _b.sent();
                    return [4 /*yield*/, exec.exec(opensslcmd, ['pkcs12', '-in', p12Path, '-out', '/tmp/step1.openssl', '-nokeys', '-passin', 'pass:' + p12Pwd])];
                case 2:
                    _b.sent();
                    opensslopts = {};
                    opensslopts.listeners = {
                        stdout: function (data) {
                            output = output + data.toString();
                        }
                    };
                    _b.label = 3;
                case 3:
                    _b.trys.push([3, 5, , 6]);
                    return [4 /*yield*/, exec.exec(opensslcmd, ['x509', '-in', '/tmp/step1.openssl', '-noout', '-fingerprint', '-subject', '-dates'], opensslopts)];
                case 4:
                    _b.sent();
                    line = void 0;
                    for (_i = 0, _a = output.split('\n'); _i < _a.length; _i++) {
                        line = _a[_i];
                        onLine(line);
                    }
                    return [3 /*break*/, 6];
                case 5:
                    err_3 = _b.sent();
                    if (!p12Pwd) {
                        core.warning('NoP12PwdWarning');
                    }
                    throw err_3;
                case 6:
                    core.debug("P12 fingerprint: " + fingerprint);
                    core.debug("P12 common name (CN): " + commonName);
                    core.debug("NotBefore: " + notBefore);
                    core.debug("NotAfter: " + notAfter);
                    return [2 /*return*/, { fingerprint: fingerprint, commonName: commonName, notBefore: notBefore, notAfter: notAfter }];
            }
        });
    });
}
exports.getP12Properties = getP12Properties;
/**
 * Get the friendly name from the private key in a P12 file.
 * @param p12Path Path to the P12 file
 * @param p12Pwd Password for the P12 file
 */
function getP12PrivateKeyName(p12Path, p12Pwd) {
    return __awaiter(this, void 0, void 0, function () {
        var privateKeyPassword, privateKeyName, opensslPathCmd, grepCmd, grepOpts;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    //openssl pkcs12 -in <p12Path> -nocerts -passin pass:"<p12Pwd>" -passout pass:"<p12Pwd>" | grep 'friendlyName'
                    core.debug('getting the P12 private key name');
                    if (!p12Pwd) {
                        // if password is null or not defined, set it to empty
                        p12Pwd = '';
                    }
                    privateKeyPassword = p12Pwd ? p12Pwd : generatePassword();
                    return [4 /*yield*/, io.which('openssl', true)];
                case 1:
                    opensslPathCmd = _a.sent();
                    return [4 /*yield*/, io.which('grep', true)];
                case 2:
                    grepCmd = _a.sent();
                    return [4 /*yield*/, exec.exec(opensslPathCmd, ['pkcs12', '-in', p12Path, '-out', '/tmp/p12privkeyname.tmp', '-nocerts', '-passin', 'pass:' + p12Pwd, '-passout', 'pass:' + privateKeyPassword])];
                case 3:
                    _a.sent();
                    grepOpts = {};
                    grepOpts.listeners = {
                        stdout: function (data) {
                            if (data) {
                                // find the private key name
                                var trimmedData = data.toString().trim();
                                var match = trimmedData.match(/friendlyName: (.*)/);
                                if (match && match[1]) {
                                    privateKeyName = match[1].trim();
                                }
                            }
                        }
                    };
                    return [4 /*yield*/, exec.exec(grepCmd, ['friendlyName', '/tmp/p12privkeyname.tmp'], grepOpts)];
                case 4:
                    _a.sent();
                    core.debug('P12 private key name = ' + privateKeyName);
                    if (!privateKeyName) {
                        throw new Error('P12PrivateKeyNameNotFound: ' + p12Path);
                    }
                    return [2 /*return*/, privateKeyName];
            }
        });
    });
}
exports.getP12PrivateKeyName = getP12PrivateKeyName;
/**
 * Set the partition_id ACL so codesign has permission to use the signing key.
 */
function setKeyPartitionList(keychainPath, keychainPwd, privateKeyName) {
    return __awaiter(this, void 0, void 0, function () {
        var partitionList, setKeyCommand, setKeyArgs, unknownCommandErrorFound_1, incorrectPasswordErrorFound, setKeyOpts, err_4;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!privateKeyName) return [3 /*break*/, 5];
                    core.debug("Setting the partition_id ACL for " + privateKeyName);
                    partitionList = 'apple-tool:,apple:';
                    return [4 /*yield*/, io.which('security', true)];
                case 1:
                    setKeyCommand = _a.sent();
                    setKeyArgs = ['set-key-partition-list', '-S', partitionList, '-s', '-l', privateKeyName, '-k', keychainPwd, keychainPath];
                    unknownCommandErrorFound_1 = false;
                    incorrectPasswordErrorFound = void 0;
                    setKeyOpts = {};
                    // Watch for "unknown command". set-key-partition-list was added in Sierra (macOS v10.12)
                    setKeyOpts.listeners = {
                        errline: function (line) {
                            if (!unknownCommandErrorFound_1 && line.includes('security: unknown command')) {
                                unknownCommandErrorFound_1 = true;
                            }
                        }
                    };
                    _a.label = 2;
                case 2:
                    _a.trys.push([2, 4, , 5]);
                    return [4 /*yield*/, exec.exec(setKeyCommand, setKeyArgs, setKeyOpts)];
                case 3:
                    _a.sent();
                    return [3 /*break*/, 5];
                case 4:
                    err_4 = _a.sent();
                    if (unknownCommandErrorFound_1) {
                        // If we're on an older OS, we don't need to run set-key-partition-list.
                        console.log('SetKeyPartitionListCommandNotFound');
                    }
                    else {
                        core.error(err_4);
                        throw new Error('SetKeyPartitionListCommandFailed');
                    }
                    return [3 /*break*/, 5];
                case 5: return [2 /*return*/];
            }
        });
    });
}
function getUserProvisioningProfilesPath() {
    core.debug('getUserProvisioningProfilesPath()');
    return path.resolve(process.env['HOME'] || '/', 'Library', 'MobileDevice', 'Provisioning Profiles');
}
function getProvisioningProfilePath(uuid, provProfilePath) {
    var profileExtension = '';
    if (provProfilePath) {
        profileExtension = path.extname(provProfilePath);
    }
    return path.resolve(getUserProvisioningProfilesPath(), uuid.trim().concat(profileExtension));
}
function generatePassword() {
    return Math.random().toString(36);
}
function splitIntoKeyValue(line) {
    // Don't use `split`. The value may contain `=` (e.g. "/UID=E848ASUQZY/CN=iPhone Developer: ...")
    var index = line.indexOf('=');
    if (index) {
        return { key: line.substring(0, index), value: line.substring(index + 1) };
    }
    else {
        return undefined;
    }
}
function getProvisioningProfileDetails(profProfilePath) {
    return __awaiter(this, void 0, void 0, function () {
        var securityCmd, provProfileDetails_1, getCloudOpts;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    core.debug('getProvisioningProfileDetails()');
                    if (!ioutils.exists(profProfilePath)) return [3 /*break*/, 3];
                    return [4 /*yield*/, io.which('security', true)];
                case 1:
                    securityCmd = _a.sent();
                    getCloudOpts = {};
                    getCloudOpts.listeners = {
                        stdout: function (data) {
                            if (data) {
                                if (provProfileDetails_1) {
                                    provProfileDetails_1 = provProfileDetails_1.concat(data.toString().trim().replace(/[,\n\r\f\v]/gm, ''));
                                }
                                else {
                                    provProfileDetails_1 = data.toString().trim().replace(/[,\n\r\f\v]/gm, '');
                                }
                            }
                        }
                    };
                    return [4 /*yield*/, exec.exec(securityCmd, ['cms', '-D', '-i', profProfilePath], getCloudOpts)];
                case 2:
                    _a.sent();
                    core.debug('called security cms -D -i ' + profProfilePath);
                    return [2 /*return*/, provProfileDetails_1];
                case 3:
                    core.error('supplied provisioning profile path does not exist.');
                    throw new Error('ProvProfileNotFound');
            }
        });
    });
}
function saveProvisioningProfileDetails(profProfilePath, writeToFile) {
    return __awaiter(this, void 0, void 0, function () {
        var details;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    core.debug('saveProvisioningProfileDetails()');
                    return [4 /*yield*/, getProvisioningProfileDetails(profProfilePath)];
                case 1:
                    details = _a.sent();
                    if (details) {
                        //write the provisioning profile to a plist
                        ioutils.writeFile(writeToFile, details);
                        core.debug('wrote provisioning profile as plist to ' + writeToFile);
                    }
                    else {
                        throw new Error('ProvProfileDetailsNotFound: ' + profProfilePath);
                    }
                    return [2 /*return*/, details];
            }
        });
    });
}
function execPlistBuddyCommand(command, plistfile) {
    return __awaiter(this, void 0, void 0, function () {
        var results, plistCmd, plistArgs, plistOpts;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, io.which('/usr/libexec/PlistBuddy', true)];
                case 1:
                    plistCmd = _a.sent();
                    plistArgs = ['-c', command, plistfile];
                    plistOpts = {};
                    plistOpts.listeners = {
                        stdout: function (data) {
                            if (data) {
                                results = data.toString().trim();
                            }
                        }
                    };
                    return [4 /*yield*/, exec.exec(plistCmd, plistArgs, plistOpts)];
                case 2:
                    _a.sent();
                    return [2 /*return*/, results];
            }
        });
    });
}
